"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseVTExpression = exports.evaluateValue = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const parser_1 = require("@babel/parser");
function evaluateValue(expression) {
    const ret = { status: 'ng', value: undefined };
    try {
        const ast = parser_1.parse(`const a = ${expression.trim()}`);
        const node = ast.program.body[0].declarations[0].init;
        if (node.type === 'StringLiteral' || node.type === 'ObjectExpression') {
            const val = new Function(`return ${expression.trim()}`)();
            ret.status = 'ok';
            ret.value = val;
        }
    }
    catch (e) { }
    return ret;
}
exports.evaluateValue = evaluateValue;
function parseVTExpression(expression) {
    const ret = {
        path: '',
        named: {},
        options: {}
    };
    try {
        const ast = parser_1.parse(`const a = ${expression.trim()}`);
        const node = ast.program.body[0].declarations[0].init;
        if (node.type === 'StringLiteral') {
            ret.path = node.extra.raw;
        }
        else if (node.type === 'Identifier') {
            ret.path = node.name;
        }
        else if (node.type === 'MemberExpression') {
            ret.path = getObjectMemberValue(node);
        }
        else if (node.type === 'ObjectExpression') {
            node.properties.forEach((propNode) => {
                const propKeyNode = propNode.key;
                if (propKeyNode.type !== 'Identifier') {
                    return;
                }
                const propValueNode = propNode.value;
                switch (propKeyNode.name) {
                    case 'path':
                        ret.path = getObjectMemberValue(propValueNode);
                        break;
                    case 'locale':
                        ret.options.locale = getObjectMemberValue(propValueNode);
                        break;
                    case 'choice':
                    case 'plural':
                        ret.options.plural = getObjectMemberValue(propValueNode);
                        break;
                    case 'args':
                        // console.log('args', propValueNode)
                        traverseObjectMember(propValueNode, ret.named);
                        break;
                    default:
                        break;
                }
            });
        }
    }
    catch (e) { }
    return ret;
}
exports.parseVTExpression = parseVTExpression;
function getObjectMemberValue(node) {
    if (node.type === 'StringLiteral' || node.type === 'NumericLiteral') {
        return node.extra.raw;
    }
    else if (node.type === 'Identifier') {
        return node.name;
    }
    else if (node.type === 'MemberExpression') {
        const paths = [];
        collectMermberPath(node, paths);
        paths.reverse();
        return paths.join('.');
    }
    else {
        return '';
    }
}
function traverseObjectMember(node, target) {
    node.properties.forEach((propNode) => {
        const propKeyNode = propNode.key;
        if (propKeyNode.type !== 'Identifier') {
            return;
        }
        if (!(propKeyNode.name in target)) {
            target[propKeyNode.name] = {};
        }
        // console.log('propNode', propNode)
        const propValueNode = propNode.value;
        if (propValueNode.type === 'ObjectExpression') {
            traverseObjectMember(propValueNode, target[propKeyNode.name]);
        }
        else {
            target[propKeyNode.name] = getObjectMemberValue(propValueNode);
        }
    });
}
function collectMermberPath(node, paths) {
    if (node.type === 'Identifier') {
        paths.push(node.name);
        return;
    }
    if (node.property.type === 'Identifier') {
        paths.push(node.property.name);
        return collectMermberPath(node.object, paths);
    }
}
/* eslint-enable @typescript-eslint/no-explicit-any */
